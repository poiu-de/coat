/*
 * Copyright (C) 2020 - 2024 The Coat Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.poiu.coat;

import de.poiu.coat.convert.util.CoatConversionUtils;
import de.poiu.coat.convert.converters.Converter;
import de.poiu.coat.convert.listparsers.ListParser;
import de.poiu.coat.convert.TypeConversionException;
import de.poiu.coat.convert.UncheckedTypeConversionException;
import de.poiu.coat.validation.ImmutableValidationFailure;
import de.poiu.coat.validation.ValidationFailure;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicReference;
import java.util.regex.Pattern;

import static de.poiu.coat.validation.ValidationFailure.Type.MISSING_MANDATORY_VALUE;
import static de.poiu.coat.validation.ValidationFailure.Type.UNPARSABLE_VALUE;
import static java.lang.System.Logger.Level.WARNING;
import static java.nio.charset.StandardCharsets.UTF_8;


/**
 * Base class for all config builders generated by Coat.
 * <p>
 * This class provides all the gory defails of calling different converters for the corresponding
 * types and whether to return a default value or not.
 * <p>
 * This class is not thread-safe and should not be used from multiple threads simultaneously.
 */
public abstract class CoatConfigBuilder {

  private static final System.Logger LOGGER= System.getLogger(CoatConfigBuilder.class.getName());

  private static final Pattern PATTERN_UNDERSCORES_IN_HEX   = Pattern.compile("(?<=[a-fA-F\\d])_+(?=[a-fA-F\\d])");
  private static final Pattern PATTERN_UNDERSCORES_IN_NUMBER= Pattern.compile("(?<=\\d)_+(?=\\d)");


  //////////////////////////////////////////////////////////////////////////////
  //
  // Attributes

  private final Map<String, String>         props                = new HashMap<>();

  private final CoatParam[]                 params;

  private final Map<Class<?>, Converter<?>> classLocalConverters = new ConcurrentHashMap<>();

  private final AtomicReference<ListParser> customListParser     = new AtomicReference<>(CoatConversionUtils.getGlobalListParser()); // by default equal to the global ListParser


  //////////////////////////////////////////////////////////////////////////////
  //
  // Constructors

  protected CoatConfigBuilder(final CoatParam[] params) {
    this.params= params;
  }


  //////////////////////////////////////////////////////////////////////////////
  //
  // Methods

  /**
   * Add the given properties to the current ones. Already existing properties will be overwritten
   * with the new values.
   * <p>
   * Returns this CoatConfigBuilder for method chaining.
   *
   * @param props the map with the config data to add
   * @return this CoatConfigBuilder
   */
  protected CoatConfigBuilder add(final Map<String, String> props) {
    this.props.putAll(props);
    return this;
  }


  /**
   * Get the value for the given key.
   * No special logic is applied. The value is returned exactly as contained in the configuration.
   * <p>
   * No default values will be respected. If the given key doesn't have a value, {@code null} is
   * returned.
   *
   * @param key the config key
   * @return the value of the config key as String
   */
  protected String get(final String key) {
    return this.props.get(key);
  }


  /**
   * Get the value for the given configParam.
   * The value will be returned in the type specified in the ConfigParam by utilizing the registered
   * converter for that type.
   * <p>
   * No default values will be respected. If the given key doesn't have a value, {@code null} is
   * returned.
   *
   * @param <T> the type of the configParam to return
   * @param configParam the configParam
   * @return the value of the config key
   */
  protected <T> T get(final CoatParam configParam) throws UncheckedTypeConversionException {
    final String stringValue= this.getString(configParam);
    try {
      return this.convertValue(stringValue, configParam);
    } catch (TypeConversionException e) {
      throw new UncheckedTypeConversionException("Error converting value " + stringValue + " to type " + configParam.type().getName(), e);
    }
  }


  protected <T> T[] getArrayOrDefault(final CoatParam configParam) throws UncheckedTypeConversionException {
    final String stringValue= this.props.get(configParam.key());
    if (stringValue != null && !stringValue.trim().isEmpty()) {
      return getArray(configParam);
    } else {
      try {
        final ListParser listParser = this.getListParser(configParam);
        final String[] stringValues = listParser.convert(configParam.defaultValue());
        return getArray(configParam, stringValues);
      } catch (TypeConversionException ex) {
        throw new UncheckedTypeConversionException("Error splitting value " + stringValue + " into a list", ex);
      }
    }
  }


  protected <T> T[] getArray(final CoatParam configParam) throws UncheckedTypeConversionException {
    final String stringValue= this.getString(configParam);
    try {
      final ListParser listParser = this.getListParser(configParam);
      final String[] stringValues = listParser.convert(stringValue);
      return getArray(configParam, stringValues);
    } catch (TypeConversionException ex) {
      throw new UncheckedTypeConversionException("Error splitting value " + stringValue + " into a list", ex);
    }
  }


  protected <T> List<T> getList(final CoatParam configParam) throws UncheckedTypeConversionException {
    return List.of(getArray(configParam));
  }


  protected <T> List<T> getListOrDefault(final CoatParam configParam) throws UncheckedTypeConversionException {
    return List.of(getArrayOrDefault(configParam));
  }


  protected <T> Set<T> getSet(final CoatParam configParam) throws UncheckedTypeConversionException {
    return Set.of(getArray(configParam));
  }


  protected <T> Set<T> getSetOrDefault(final CoatParam configParam) throws UncheckedTypeConversionException {
    return Set.of(getArrayOrDefault(configParam));
  }


  protected <T> Optional<T> getOptional(final CoatParam configParam) {
    final String stringValue= this.getString(configParam);
    if (stringValue == null || stringValue.trim().isEmpty()) {
      return Optional.empty();
    } else {
      try {
        final T t= this.convertValue(stringValue, configParam);
        return Optional.of(t);
      } catch (TypeConversionException e) {
        throw new RuntimeException("Error converting value", e);
      }
    }
  }


  protected <T> T getOrDefault(final CoatParam configParam) {
    final String stringValue= this.getStringOrDefault(configParam);
    try {
      return this.convertValue(stringValue, configParam);
    } catch (TypeConversionException e) {
      throw new RuntimeException("Error converting value", e);
    }
  }


  /**
   *
   * @deprecated A parameter that is optional _and_ has a default value does not make sense.
   *             The optional will _never_ be null as it will at least contain the default value.
   */
  @Deprecated
  protected <T> Optional<T> getOptionalOrDefault(final CoatParam configParam) {
    final String stringValue= this.getStringOrDefault(configParam);
    try {
      return Optional.of(this.convertValue(stringValue, configParam));
    } catch (TypeConversionException e) {
      throw new RuntimeException("Error converting value", e);
    }
  }


  protected String getString(final CoatParam configParam) {
    return this.props.get(configParam.key());
  }


  protected String getStringOrDefault(final CoatParam configParam) {
    return this.props.getOrDefault(configParam.key(), configParam.defaultValue());
  }


  protected Optional<String> getOptionalString(final CoatParam configParam) {
    final String value= this.props.get(configParam.key());
    return Optional.ofNullable(value);
  }


  protected int getInt(final CoatParam configParam) {
    final String stringValue= this.props.get(configParam.key());
    return this.parseInt(stringValue);
  }


  protected int getIntOrDefault(final CoatParam configParam) {
    final String stringValue= this.props.get(configParam.key());
    if (stringValue != null && !stringValue.trim().isEmpty()) {
      return this.parseInt(stringValue);
    } else {
      return this.parseInt(configParam.defaultValue());
    }
  }


  protected OptionalInt getOptionalInt(final CoatParam configParam) {
    final String stringValue= this.props.get(configParam.key());
    if (stringValue != null && !stringValue.trim().isEmpty()) {
      final int value= this.parseInt(stringValue);
      return OptionalInt.of(value);
    } else {
      return OptionalInt.empty();
    }
  }


  /**
   *
   * @param configParam
   * @return
   * @deprecated A parameter that is optional _and_ has a default value does not make sense.
   *             The optional will _never_ be null as it will at least contain the default value.
   */
  @Deprecated
  protected OptionalInt getOptionalIntOrDefault(final CoatParam configParam) {
    final String stringValue= this.props.get(configParam.key());
    if (stringValue != null && !stringValue.trim().isEmpty()) {
      return OptionalInt.of(this.parseInt(stringValue));
    } else {
      return OptionalInt.of(this.parseInt(configParam.defaultValue()));
    }
  }


  protected long getLong(final CoatParam configParam) {
    final String stringValue= this.props.get(configParam.key());
    return this.parseLong(stringValue);
  }


  protected long getLongOrDefault(final CoatParam configParam) {
    final String stringValue= this.props.get(configParam.key());
    if (stringValue != null && !stringValue.trim().isEmpty()) {
      return this.parseLong(stringValue);
    } else {
      return this.parseLong(configParam.defaultValue());
    }
  }


  protected OptionalLong getOptionalLong(final CoatParam configParam) {
    final String stringValue= this.props.get(configParam.key());
    if (stringValue != null && !stringValue.trim().isEmpty()) {
      final long value= this.parseLong(stringValue);
      return OptionalLong.of(value);
    } else {
      return OptionalLong.empty();
    }
  }


  /**
   *
   * @param configParam
   * @return
   * @deprecated A parameter that is optional _and_ has a default value does not make sense.
   *             The optional will _never_ be null as it will at least contain the default value.
   */
  @Deprecated
  protected OptionalLong getOptionalLongOrDefault(final CoatParam configParam) {
    final String stringValue= this.props.get(configParam.key());
    if (stringValue != null && !stringValue.trim().isEmpty()) {
      return OptionalLong.of(this.parseLong(stringValue));
    } else {
      return OptionalLong.of(this.parseLong(configParam.defaultValue()));
    }
  }


  protected double getDouble(final CoatParam configParam) {
    final String stringValue= this.props.get(configParam.key());
    return this.parseDouble(stringValue);
  }


  protected double getDoubleOrDefault(final CoatParam configParam) {
    final String stringValue= this.props.get(configParam.key());
    if (stringValue != null && !stringValue.trim().isEmpty()) {
      return this.parseDouble(stringValue);
    } else {
      return this.parseDouble(configParam.defaultValue());
    }
  }


  protected OptionalDouble getOptionalDouble(final CoatParam configParam) {
    final String stringValue= this.props.get(configParam.key());
    if (stringValue != null && !stringValue.trim().isEmpty()) {
      final double value= this.parseDouble(stringValue);
      return OptionalDouble.of(value);
    } else {
      return OptionalDouble.empty();
    }
  }


  /**
   *
   * @param configParam
   * @return
   * @deprecated A parameter that is optional _and_ has a default value does not make sense.
   *             The optional will _never_ be null as it will at least contain the default value.
   */
  @Deprecated
  protected OptionalDouble getOptionalDoubleOrDefault(final CoatParam configParam) {
    final String stringValue= this.props.get(configParam.key());
    if (stringValue != null && !stringValue.trim().isEmpty()) {
      return OptionalDouble.of(Double.parseDouble(stringValue));
    } else {
      return OptionalDouble.of(Double.parseDouble(configParam.defaultValue()));
    }
  }


  protected boolean getBoolean(final CoatParam configParam) {
    final String value= this.props.get(configParam.key());
    if (value != null &&
      (value.trim().equals(1)
      || value.trim().equalsIgnoreCase("true")
      || value.trim().equalsIgnoreCase("yes"))) {
      return true;
    } else {
      // FIXME: Also define a set of valid "false" values?
      //        like: 0, "", null, no, false
      //        and throw ParsingException if anything other is contained
      return false;
    }
  }


  protected boolean getBooleanOrDefault(final CoatParam configParam) {
    final String value= this.props.getOrDefault(configParam.key(), configParam.defaultValue());
    if (value != null &&
      (value.trim().equals(1)
      || value.trim().equalsIgnoreCase("true")
      || value.trim().equalsIgnoreCase("yes"))) {
      return true;
    } else {
      // FIXME: Also define a set of valid "false" values?
      //        like: 0, "", null, no, false
      //        and throw ParsingException if anything other is contained
      return false;
    }
  }


  private <T> T[] getArray(final CoatParam configParam, final String[] stringValues) throws UncheckedTypeConversionException {
    final T[] array= (T[]) Array.newInstance(configParam.type(), stringValues.length);
    for (int i= 0; i<stringValues.length; i++) {
      try {
        array[i]= this.convertValue(stringValues[i], configParam);
      } catch (TypeConversionException e) {
        throw new UncheckedTypeConversionException("Error converting value " + stringValues[i] + " to type " + configParam.type().getName(), e);
      }
    }

    return array;
  }


  protected <T> T convertValue(final String stringValue, final CoatParam configParam) throws TypeConversionException {
    Converter<?> converter= null;
    // First try the converter that was explicitly configured for this field
    final Class<? extends Converter<?>> paramConverterClass = configParam.converter();
    if (paramConverterClass != null) {
      try {
        converter = paramConverterClass.getConstructor().newInstance();
      } catch (NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
        throw new TypeConversionException("Error converting “" + stringValue + "” for type “" + configParam.type() + "” via explicit converter “" + paramConverterClass.getCanonicalName() + "”.", ex);
      }
    }
    // Then try the converter registered for this CoatConfigBuilder
    if (converter == null) {
      converter= this.classLocalConverters.get(configParam.type());
    }
    // Finally try the default converter
    if (converter == null) {
      converter= CoatConversionUtils.getGlobalConverter(configParam.type());
    }

    if (converter == null) {
      throw new TypeConversionException("No converter registered for type '" + configParam.type().getTypeName() + "'.");
    }

    return (T) converter.convert(stringValue);
  }


  protected void tryConversion(final String stringValue, final CoatParam configParam) throws TypeConversionException {
    if (this.isPrimitive(configParam)) {
      this.convertPrimitive(stringValue, configParam);
      return;
    }

    if (this.isCollection(configParam)) {
      final ListParser listParser = this.getListParser(configParam);
      final String[] values = listParser.convert(stringValue);
      for (final String value : values) {
        this.convertValue(value, configParam);
      }
      return;
    }


    Converter<?> converter= null;
    // First try the converter that was explicitly configured for this field
    final Class<? extends Converter<?>> paramConverterClass = configParam.converter();
    if (paramConverterClass != null) {
      try {
        converter = paramConverterClass.getConstructor().newInstance();
      } catch (NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
        throw new TypeConversionException("Error converting “" + stringValue + "” for type “" + configParam.type() + "” via explicit converter “" + paramConverterClass.getCanonicalName() + "”.", ex);
      }
    }
    // Then try the converter registered for this CoatConfigBuilder
    if (converter == null) {
      converter= this.classLocalConverters.get(configParam.type());
    }
    // Finally try the default converter
    if (converter == null) {
      converter= CoatConversionUtils.getGlobalConverter(configParam.type());
    }

    if (converter == null) {
      throw new TypeConversionException("No converter registered for type '" + configParam.type().getTypeName() + "'.");
    }

    converter.convert(stringValue);
  }


  protected void convertPrimitive(final String stringValue, final CoatParam param) throws TypeConversionException {
    if (param.type().equals(int.class)) {
      try {
        this.parseInt(stringValue);
      } catch (NumberFormatException ex) {
        throw new TypeConversionException("Error converting value to int", ex);
      }
    } else if (param.type().equals(long.class)) {
      try {
        this.parseLong(stringValue);
      } catch (NumberFormatException ex) {
        throw new TypeConversionException("Error converting value to long", ex);
      }
    } else if (param.type().equals(double.class)) {
      try {
        Double.valueOf(stringValue);
      } catch (NumberFormatException ex) {
        throw new TypeConversionException("Error converting value to double", ex);
      }
    } else if (param.type().equals(boolean.class)) {
      // boolean values are always valid at the moment
    }
  }


  private ListParser getListParser(final CoatParam configParam) throws TypeConversionException {
    // First try the ListParser that was explicitly configured for this field
    final Class<? extends ListParser> paramListParserClass = configParam.listParser();
    if (paramListParserClass != null) {
      try {
        return paramListParserClass.getConstructor().newInstance();
      } catch (NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
        throw new TypeConversionException("Error instantiating “" + paramListParserClass.getCanonicalName() + "”.", ex);
      }
    }

    // Then try the converter registered for this CoatConfigBuilder
    final ListParser customListParser= this.customListParser.get();
    if (customListParser != null) {
      return customListParser;
    }

    // Then try the ListParser registered for this CoatConfigBuilder (or the default one)
    return CoatConversionUtils.getGlobalListParser();
  }


  private boolean isPrimitive(final CoatParam param) {
    return param.type().isPrimitive();
  }


  private boolean isCollection(final CoatParam param) {
    return param.collectionType() != null;
  }


  protected List<ValidationFailure> validate() {
    final List<ValidationFailure> validationFailures= new ArrayList<>();

    // try to convert all values of this object
    for (final CoatParam configParam : this.params) {
      final String stringValue= this.props.get(configParam.key());

      // verify missing mandatory parameters
      if (configParam.mandatory() && configParam.defaultValue() == null && stringValue == null) {
        validationFailures.add(this.createMissingKeyFailure(configParam.key()));
      }

      if (stringValue != null) {
        // verify correct conversion of values
        final String valueOrDefault= stringValue != null ? stringValue : configParam.defaultValue();
        try {
          this.tryConversion(valueOrDefault, configParam);
        } catch (TypeConversionException ex) {
          validationFailures.add(this.createUnparsableValueFailure(configParam.key(), configParam.type(), valueOrDefault, ex.getMessage()));
        }
      }
    }

    return validationFailures;
  }


  protected CharSequence getParamStrings() {
    final List<StringRepresentation> paramStrings= this.getParamStringRepresentations();
    final StringBuilder sb= new StringBuilder();
    for (final StringRepresentation str : paramStrings) {
      sb.append("  ").append(str.key).append("  ").append(str.type).append(": ").append(str.value).append('\n');
    }
    return sb;
  }


  private List<StringRepresentation> getParamStringRepresentations() {
    final List<StringRepresentation> paramStrings= new ArrayList<>(this.params.length);
    for (final CoatParam configParam : this.params) {
      final String  key             = configParam.key();
      final String  type            = configParam.type().getName();
      final String  value           = this.props.get(key);
      final String  valueOrDefault  = this.props.getOrDefault(key, configParam.defaultValue());
      final boolean isOptional      = configParam.mandatory();
      final boolean isCollection    = configParam.collectionType() != null;
      final boolean hasDefaultValue = configParam.defaultValue() != null && !configParam.defaultValue().equals("");
      final boolean isDefaultValue  = value == null && hasDefaultValue;

      paramStrings.add(new StringRepresentation(
        key,
        "[" + (isOptional ? "?" : " ") + type + (isCollection ? "*" : " ") + "]",
        valueOrDefault + (isDefaultValue ? " (default)" : "")
      ));
    }
    CoatConfigBuilder.padStrings(paramStrings);

    return paramStrings;
  }


  private static void padStrings(final Collection<StringRepresentation> strs) {
    int maxKeyLength = 0;
    int maxTypeLength= 0;
    for (final StringRepresentation str : strs) {
      maxKeyLength = Math.max(maxKeyLength, str.key.length());
      maxTypeLength= Math.max(maxTypeLength, str.type.length());
    }

    for (final StringRepresentation str : strs) {
      str.key = rPad(str.key,  maxKeyLength,  ' ');
      str.type= rPad(str.type, maxTypeLength, ' ');
    }
  }


  private static CharSequence rPad(final CharSequence s, final int length, final char c) {
    final int padLength = Math.max(0, length - s.length());

    final StringBuilder sb = new StringBuilder();
    sb.append(s);
    sb.append(String.valueOf(c).repeat(padLength));

    return sb;
  }


  protected ImmutableValidationFailure createMissingKeyFailure(final String key) {
    return ImmutableValidationFailure.builder()
      .failureType(MISSING_MANDATORY_VALUE)
      .key(key)
      .build();
  }


  protected ImmutableValidationFailure createUnparsableValueFailure(final String key, final Class<?> type, final String value, final String errorMsg) {
    return ImmutableValidationFailure.builder()
      .failureType(UNPARSABLE_VALUE)
      .key(key)
      .type(type.getName())
      .value(value)
      .errorMsg(errorMsg)
      .build();
  }


  /**
   * Register a custom converter for this config class.
   * @param converter The converter to register
   */
  protected void registerCustomConverter(final Converter<?> converter) {
    try {
      final Class<?> type= CoatConversionUtils.getConverterBaseType(converter.getClass());
      this.classLocalConverters.put(type, converter);
    } catch (TypeConversionException ex) {
      throw new UncheckedTypeConversionException("Error trying to find base class of converter “" + converter.getClass().getCanonicalName() + "”", ex);
    }
  }


  /**
   * Register a custom ListParser for this config class.
   * @param listParser the ListParser to register
   */
  protected void registerCustomListParser(final ListParser listParser) {
    this.customListParser.set(listParser);
  }


  protected static Map<String, String> filterByAndStripPrefix(final Map<String, String> map, final String prefix) {
    final Map<String, String> filtered= new HashMap<>();

    for (final Map.Entry<String, String> e : map.entrySet()) {
      final String key = e.getKey();
      final String val = e.getValue();

      if (key.startsWith(prefix)) {
        final String strippedKey= key.substring(prefix.length());
        filtered.put(strippedKey, val);
      }
    }

    return filtered;
  }


  protected boolean hasPrefix(final Map<String, String> props, final String prefix) {
    for (final String key : props.keySet()) {
      if (key.startsWith(prefix)) {
        return true;
      }
    }

    return false;
  }


  protected static Map<String, String> toMap(final Properties jup) {
    final Map<String, String> map= new HashMap<>(jup.size());

    for (final Map.Entry<Object, Object> entry : jup.entrySet()) {
      if (entry.getKey() instanceof String && entry.getValue() instanceof String ) {
        map.put((String) entry.getKey(), (String) entry.getValue());
      } else {
        LOGGER.log(WARNING, "Ignoring non-string entry: {0} = {1}", new Object[]{entry.getKey(), entry.getValue()});
      }
    }

    return map;
  }


  protected static Map<String, String> toMap(final File file) throws IOException {
    final Properties jup= new Properties();
    jup.load(new FileReader(file, UTF_8));
    return toMap(jup);
  }


  private int parseInt(final String stringValue) {
    final String number= removeOptionalUnderscores(stringValue);
    if (number.startsWith("0x")) {
      // hex value
      return Integer.parseInt(number.substring(2), 16);
    } else if (number.startsWith("0b")) {
      // bin value
      return Integer.parseInt(number.substring(2), 2);
    } else if (number.startsWith("0")) {
      // oct value
      return Integer.parseInt(number.substring(1), 8);
    } else {
      // dec value
      return Integer.parseInt(number);
    }
  }


  private long parseLong(final String stringValue) {
    final String number= removeOptionalUnderscores(stringValue);
    if (number.startsWith("0x")) {
      // hex value
      return Long.parseLong(number.substring(2), 16);
    } else if (number.startsWith("0b")) {
      // bin value
      return Long.parseLong(number.substring(2), 2);
    } else if (number.startsWith("0")) {
      // oct value
      return Long.parseLong(number.substring(1), 8);
    } else {
      // dec value
      return Long.parseLong(number);
    }
  }


  private double parseDouble(final String stringValue) {
    final String number= removeOptionalUnderscores(stringValue);
    return Double.parseDouble(number);
  }


  /**
   * Remove optional underscores in the middle of the number. The behaviour is the same as
   * the Java parser applies. All underscores in the string are removed, but no underscore is allowed
   * before the first and the last digit.
   *
   * @param number
   * @return
   */
  private String removeOptionalUnderscores(final String number) {
    if (number.startsWith("0x")) {
      return PATTERN_UNDERSCORES_IN_HEX.matcher(number).replaceAll("");
    } else {
      return PATTERN_UNDERSCORES_IN_NUMBER.matcher(number).replaceAll("");
    }
  }


  /**
   * Remove optional underscores in the middle of the number. The behaviour is the same as
   * the Java parser applies. All underscores in the string are removed, but no underscore is allowed
   * before the first and the last digit.
   *
   * This variant is a bit faster than {@link #removeOptionalUnderscores(java.lang.String)} since
   * it avoids the usage of regular expressions. It is more than twice as fast.
   *
   * @param number
   * @return
   */
  private static CharSequence removeOptionalUnderscores_Fast(final String number) {
    final StringBuilder sb= new StringBuilder();

    final boolean isHex= number.startsWith("0x");
    char lastChar= '\0';
    for (int i= 0; i < number.length(); i++) {
      final char c= number.charAt(i);
      if (c == '_' && i < number.length()-1) {
        if (Character.isDigit(lastChar)) {
          continue;
        }
        if (isHex &&
            (lastChar == 'a' || lastChar == 'A' || lastChar == 'b' || lastChar == 'B'
          || lastChar == 'c' || lastChar == 'C' || lastChar == 'd' || lastChar == 'D'
          || lastChar == 'e' || lastChar == 'E' || lastChar == 'f' || lastChar == 'F')) {
          continue;
        }
      }

      sb.append(c);
      lastChar= c;
    }

    return sb;
  }
}
