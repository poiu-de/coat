[{"body":"Coat provides three annotations, a type-level annotation @Coat.Config and two method-level annotations @Coat.Param and @Coat.Embedded.\nThe type-level annotation is mandatory. It is the indicator for the annotation processor which interfaces need to be proceessed.\n@Coat.Param and @Coat.Embedded are mutually exclusive.\n@Coat.Config Each interface that should be processed by the annotation processor must be annotated with @Coat.Config.\nThe generated class will always be generated in the same package as the annotated interface.\nThe name of the generated class is by the default the interface name with Immutable prepended to it. One exception is if the interface name starts with an underscore. In that case the generated class name is the same as the interface, but with the leading underscore removed. Therefore for the interface _MyConfig the generated class would be MyConfig.\n@Coat.Config (Javadoc) supports the following attributes:\nclassName The className can be specified to generate a class with a different name than when applying the above mentioned naming rules. When className is specified it will be used as the generated class name. It will still be generated in the same package as the annotated interface.\n1@Coat.Config(className = \u0026#34;MyAppConfig\u0026#34;) 2public interface AppConfig { 3 … 4} casing By default (if not explicitly specified by @Coat.Param#key) Coat expects the key in the config file exactly as the accessor methods name (respecting upper/lower case). To allow for different formats of keys without having to explicitly declare each key, Coat provides a CasingStrategy.\nAS_IS The default. The key is expected in the same case as the accessor methods name. SNAKE_CASE The typical snakeCase of Java method names is converted to snake_case. For example the method name “listenPort” would then be specified as “listen_port” in the config file. KEBAB_CASE Similar to SNAKE_CASE, but instead of underscores an hyphen is used. “listenPort” would be expected as “listen-port”. All the above strategies expect the accessor method names in camelCase (conforming to the Java code formatting conventions). Deviating from that conventions may lead to unexpected results.\n1@Coat.Confg(casing = SNAKE_CASE) 2public interface AppConfig { 3 … 4} stripGetPrefix Coat is agnostic to the naming conventions of the accessor methods. Using the Java Bean Convention of prefixing the methods with “get” leads to strange config keys (that also include the “get” prefix). Therefore Coat strips these prefixes before inferring the key. So the accessor method “getListenPort” would be specified as “listenPort” in the config file,\nIf the “get” prefix should not be stripped for some reason, the stripGetPrefix can be set to false to prohibit that behavior.\n1@Coat.Confg(stripGetPrefix = false) 2public interface AppConfig { 3 public boolean getMeABeer(); 4 … 5} converters Coat supports registering custom converters via a static method on the CoatConfig class.\nConverters can also be registered declaratively with the converters attribute. It expects an array of Converter classes to register.\n1@Coat.Confg(converters = { 2 UuidConverter.class, 3 CurrencyConverter.class, 4}) 5public interface AppConfig { 6 public UUID uuid(); 7 public Currency currency(); 8 … 9} listParser Since version 0.0.4 Coat supports Arrays and other collection types. By default it splits the values given in the config file on whitespace. To define a different format to use for Arrays and collections a custom ListParser can be registered.\n1@Coat.Confg(listParser = CommaSeparatedListParser.class) 2public interface AppConfig { 3 public InetAddress[] remoteAdresses(); 4 … 5} @Coat.Param Since version 0.0.4 the @Coat.Param annotation on accessor methods is optional.\n@Coat.Param (Javadoc) supports the following attributes:\nkey The parameter key specifies the name of the key as it must be specified in the config file (or the Properties or Map object with which the config class is instantiated).\nIf this key is not specified, it will be automatically inferred from the accessor methods name, respecting the casing and stripGetPrefix parameters of the corresponding @Coat.Config annotation. By default the key will be exactly the same as the accessor methods name.\n1@Coat.Param(key = \u0026#34;listen-port\u0026#34;) 2public int port(); defaultValue A parameter defaultValue can be specified to define a default value that will be used if the config key is missing in the config file. The default value must be specified as a String in the same form it would be specified in the config file. For example:\n1@Coat.Param(defaultValue = \u0026#34;8080\u0026#34;) 2public int port(); The generated config would return the value that was specified in the config file or 8080 if no port was specified.\nconverter Additionally to the corresponding parameter on the @CoatConfig annotation a converter can be specified on the accessor method itself. This will override the default converter specified on the interface level.\n1@Coat.Param(converter = MyDateConverter.class) 2public LocalDate startTime(); Use this attribute sparingly and prefer the corresponding attribute on the interface-level annotation @Coat.Config as different formats for the same data types in the same config can be very surprising.\nlistParser Additionally to the corresponding parameter on the @CoatConfig annotation a ListParser can be specified on the accessor method itself. This will override the default ListParser specified on the interface level.\n1@Coat.Param(listParser = MyListParser.class) 2public String[] preferredRoles(); Use this attribute sparingly and prefer the corresponding attribute on the interface-level annotation @Coat.Config as different formats for specifying lists in the same config can be very surprising.\n@Coat.Embedded When using nested configurations the annotation @Coat.Embedded must be used instead of @Coat.Param on the corresponding accessor method.\nWhen using @Coat.Embedded the return type of the accessor method must be a @Coat.Config annotated interface.\n@Coat.Embedded (Javadoc) supports the following attributes:\nkey The parameter key specifies the prefix for the config parameters of the embedded config. See @Coat.Param#key for more details about this attribute.\n1@Coat.Embedded(key = \u0026#34;broker\u0026#34;) 2public MqttConfig mqtt(); keySeparator The parameter keySeparator can be specified to define the separator between the prefix and the actual config key of the embedded config. It defaults to a single dot.\n1@Coat.Embedded(keySeparator = \u0026#34;-\u0026#34;) 2public MqttConfig mqtt(); ","link":"https://poiu-de.github.io/coat/docs/user_guide/01_annotations/","title":"Annotations"},{"body":"The Quick Start guide should help getting started with Coat as easily as possible.\nThe User Guide is the thorough description of all aspects of Coat.\nThe Roadmap gives an overview of the possible further enhancement of Coat.\nQuick Start User Guide Roadmap\n","link":"https://poiu-de.github.io/coat/docs/","title":"Coat — Config of Annotated Types"},{"body":"Coat has no runtime dependencies on other libraries.\nThe annotation processor has some dependencies on other libraries (which is why it is recommended to use maven as it resolves those dependencies automatically), but none of them are needed at runtime.\nCoat can be used with Java 11 or higher.\n","link":"https://poiu-de.github.io/coat/docs/quick_start/01_prerequisites/","title":"Prerequisites"},{"body":"Starting with Coat is easy. Just write an interface with accessor methods for each field that should be configurable. The return values of the accessor methods can be of any type. Many types are already supported out of the box, but it is possible to use custom types.\nThe source of the configuration data doesn’t matter. While it is mainly intended to be used for the usual Java .properties files, it can be used for any data that is composed of simple String-based key-value-mappings.\nAnnotate the interface with the corresponding Annotations and let the Coat annotation processor generate a concrete implementation of the interface.\nThat implementation can then be used to retrieve correctly typed config values without any additional effort.\nPrerequisites ","link":"https://poiu-de.github.io/coat/docs/quick_start/","title":"Quick Start"},{"body":"This guide describes all aspects of Coat, how it can be configured and used. It is the full reference manual of Coat.\nAnnotations ","link":"https://poiu-de.github.io/coat/docs/user_guide/","title":"User Guide"},{"body":"Coat consists of two separate jars.\nThe annotation processor to generate the config classes. Only needed at compile time. The runtime package containing the common base class for all generated config classes and the default type converters. Needed at runtime. To use Coat in a maven based project use the following maven coordinates:\n1 \u0026lt;!-- Contains the annotation processor. Not needed at runtime. --\u0026gt; 2 \u0026lt;dependency\u0026gt; 3 \u0026lt;groupId\u0026gt;de.poiu.coat\u0026lt;/groupId\u0026gt; 4 \u0026lt;artifactId\u0026gt;coat-processor\u0026lt;/artifactId\u0026gt; 5 \u0026lt;version\u0026gt;0.0.4\u0026lt;/version\u0026gt; 6 \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; 7 \u0026lt;/dependency\u0026gt; 8 9 \u0026lt;!-- Contains the converters and base classes. Needed at runtime. --\u0026gt; 10 \u0026lt;dependency\u0026gt; 11 \u0026lt;groupId\u0026gt;de.poiu.coat\u0026lt;/groupId\u0026gt; 12 \u0026lt;artifactId\u0026gt;coat-runtime\u0026lt;/artifactId\u0026gt; 13 \u0026lt;version\u0026gt;0.0.4\u0026lt;/version\u0026gt; 14 \u0026lt;/dependency\u0026gt; ","link":"https://poiu-de.github.io/coat/docs/quick_start/02_installation/","title":"Installation"},{"body":"Coat allows embedding config objects in other config objects.\nIt is helpful in the case when parts of a configuration are reused in multiple other configurations without having to duplicate all the accessor methods of the embedded config class.\nExample As an example see the following MqttConfig that is embedded in the main AppConfig.\n1@Coat.Config 2public interface MqttConfig { 3 4 @Coat.Param(key = \u0026#34;client_id\u0026#34;) 5 public Optional\u0026lt;String\u0026gt; clientId(); 6 7 @Coat.Param(key = \u0026#34;broker_address\u0026#34;) 8 public InetAddress brokerAddress(); 9 10 @Coat.Param(key = \u0026#34;port\u0026#34;, defaultValue = \u0026#34;1883\u0026#34;) 11 public int port(); 1@Coat.Config 2public interface AppConfig { 3 4 @Coat.Param(key = \u0026#34;name\u0026#34;) 5 public String name(); 6 7 @Coat.Embedded(key = \u0026#34;mqtt\u0026#34;) 8 public MqttConfig mqtt(); A config file for that configuration would look like this:\n1name = … 2mqtt.client_id = … 3mqtt.broker_address = … 4mqtt.port = … The config keys of the embedded config get a common prefix that is specified on the @Coat.Embedded annotation of its accessor method. By default that prefix is separated from the actual config key via a single dot.\n","link":"https://poiu-de.github.io/coat/docs/user_guide/02_nesting_configurations/","title":"Nesting Configurations"},{"body":"Create config interface Write an interface with accessor methods for each config entry your application supports. The accessor methods can return the concrete types you want your config entry to be. There is a number of types that are supported by default, but custom types can be registered to support additional types.\nConfig values that are optional, must be of type java.util.Optional or the more specialized variants OptionalInt, OptionalLong or OptionalDouble. All other config values are considered mandatory. Missing mandatory values will throw exceptions at runtime.\nThe interface must be annotated with the @Coat.Config annotation for the annotation processor to recognize it.\nEach accessor may be annotated with the @Coat.Param annotation to tell the processor the corresponding key in the config file (if it should be different than what Coat would infer otherwise) or a default value in case the key is missing in the config file.\nBoth annotations have some possible attributes that can be set which are described in Annotations.\nFor example:\n1package com.example; 2 3import de.poiu.coat.annotation.Coat; 4 5@Coat.Config 6public interface AppConfig { 7 public String appName(); 8 9 public InetAddress remoteIP(); 10 11 @Coat.Param(default = \u0026#34;5044\u0026#34;) 12 public int remotePort(); 13 14 @Coat.Param(key = \u0026#34;long_description\u0026#34;) 15 public Optional\u0026lt;String\u0026gt; description(); 16} Generate concrete config class When compiling the project the annotation processor will produce a concrete implementation of the interface in the same package and (by default) the same name with Immutable prepended to it. Therefore the above example interface would produce a com.example.ImmutableAppConfig class.\nUse the generated config class At runtime the generated config class can be instantiated with either a java.io.File object referencing the actual config file, a java.util.Properties object or, if the config data is read from some other source, with a java.util.Map\u0026lt;String, String\u0026gt;.\nThe instantiated config object can be validated to fail early in case mandatory config values are missing or existing values cannot be converted to the expected type.\n1public class MyApp { 2 public static void main(String[] args) { 3 final ImmutableAppConfig config= new ImmutableAppConfig( 4 new File(\u0026#34;/path/to/config.properties\u0026#34;)); 5 6 try { 7 config.validate(); 8 } catch (final ConfigValidationException ex) { 9 System.err.println(\u0026#34;Error in config file:\\n\u0026#34; 10 + ex.getValidationResult().toString()); 11 System.exit(1); 12 } 13 14 System.out.println(\u0026#34;Starting \u0026#34; + config.appName()); 15 config.description.ifPresent(System.out::println); 16 17 final Socket s= new Socket(config.remoteIP, config.remotePort); 18 19 … 20 } 21} ","link":"https://poiu-de.github.io/coat/docs/quick_start/03_usage/","title":"Usage"},{"body":"Coat validation The generated config class allows the validation of the configuration with the method validate(). This can be used to fail early in case the given configuration is missing some values or existing values cannot be converted into the specified type.\nIf the configuration is valid this method just returns.\nIf the configuration is invalid, it will throw a ConfigValidationException. This exception has a method getValidationResult() that returns a value of type ValidationResult that contains more information about the missing or wrong config values.\nTo issue an error message, the toString() method of the ValidationResult can be used. For example\n1try { 2 config.validate(); 3} catch (final ConfigValidationException ex) { 4 System.err.println(\u0026#34;Error in config file:\\n\u0026#34; 5 + ex.getValidationResult().toString()); 6 System.exit(1); 7} Java Bean Validation While coat doesn’t provide explicit support for Java Bean Validation they can be used together.\nJava Bean Validation allows for more specific constraints on the values in a config object, e.g. minimum and maximum values of an integer. Just add the appropriate annotations to the accessor methods and validate them with a jakarta.validation.Validator.\nBe aware that Java Bean Validation requires the usage of “get” prefixes on the accessor methods. Coat explicitly supports this use case by stripping that prefix when inferring the config key by default.\nSee the example project for a usage example of Java Bean Validation with Coat.\n","link":"https://poiu-de.github.io/coat/docs/user_guide/03_validation/","title":"Validation"},{"body":"Builtin types The following types are supported by Coat out of the box and can directly be used as return types of the accessor methods in the annotated interface.\njava.lang.Integer java.lang.Long java.lang.Float java.lang.Double java.lang.String java.time.Duration java.time.LocalDate java.time.LocalDateTime java.time.LocalTime java.io.File java.nio.file.Path java.nio.charset.Charset java.net.InetAddress java.security.MessageDigest For each supported type a converter class exists in the package de.poiu.coat.convert. Refer to the corresponding Java API docs for details about the expected format of the input string.\nThe following primitive types are also supported by default. But those are different in that they are directly supported without any Converter.\nint\nInteger values can be specified in decimal (no prefix), hexadecimal (prefixed by 0x), octal (prefixed by 0) or binary (prefixed by 0b) form.\nlong\nLong values can be specified in decimal (no prefix), hexadecimal (prefixed by 0x), octal (prefixed by 0) or binary (prefixed by 0b) form.\ndouble\nDouble values can be specified in decimal (no prefix) or hexadecimal (prefixed by 0x) form.\nFor decimal values an optional exponent can be appended, in which case it must be separated with e or E, like 1.0e5. For hexadecimal values the exponent is mandatory and must be separated with p or P, like 0xaaP5. In either case the exponent can optionally be signed (e. g. 1.0e+5).\nboolean\nThe strings “true\u0026quot; and “yes” (regardless of their case) are considered as Boolean.TRUE, all other Strings (including null) are considered to be Boolean.FALSE.\nBe aware that numeric types (int, long, double) do not allow the specification of a type suffix (l for long, d for double, etc.) as would be valid in a Java literal numeric value.\nHowever, underscores for separating parts of a number (like 1_000_000) are supported.\nRegistering custom types Coat allows registering custom types to be used in the annotated interface.\nEach generated config class provides a static method registerConverter() that can be used to register a converter for a specific type. To do this, the interface de.poiu.coat.convert.Converter must be implemented for that specific type and registered with the above mentioned method.\nThe registerConverter() method must be called before an accessor method returning that type is called and before the validate() method is called.\nThe registerConverter() method can additionally be used for overriding the builtin converter for a type. For example if duration should be specified in some other format than the default converter supports, write a custom converter for the java.time.Duration type and register it via\n1ImmutableMyConfig.registerConverter(Duration.class, new MyDurationConverter()); As support for primitive types is directly implemented and not via Converter it is currently not possible to override the parsing of primitive types with a custom Converter. If different parsing of such types is necessary the corresponding object type must be used and a Converter for that type written (e. g. a Converter\u0026lt;Integer\u0026gt;).\nAdditionally to the above mentioned method of registering custom converters at runtime, they can also be specified declaratively on the corresponding annotations. See the description of these annotation parameters on the type and on the field level annotations for more information.\nCurrently unsupported types At the moment the primitive types short, float, char and byte are not supported. Therefore the next “bigger” types must be used (e. g. int instead of short) or the corresponding class (e. g. Short instead of short).\nCollection types Since version 0.0.4 Coat supports Arrays and collections as return values of accessor methods.\nArrays java.util.List java.util.Set By default the values of collection types are expected to be separated by whitespace. Whitespace inside a single value can be used by prefixing each such whitespace character with a backslash. For example the value one\\ two three would then be split into a collection with the two values one two and three.\nDefault values are supported for arrays and collections as well.\n1@Coat.Config 2public AppConfig { 3 @Coat.Param(defaultValue = \u0026#34;UTF-8 US-ASCII\u0026#34;) 4 public Charset[] allowedCharsets(); 5} Registering custom ListParser Coat allows for different formats than the default whitespace separated values by registering a custom ListParser. Each generated config class provides a static method registerListParser() to register a custom parser for such values. Additionally such a ListParser can be declared on the @Coat.Config annotation as well as on the @Coat.Param annotation.\nA custom ListParser must implement the de.poiu.coat.convert.ListParser interface.\n","link":"https://poiu-de.github.io/coat/docs/user_guide/04_supported_types/","title":"Supported Types"},{"body":"Example config file generation The annotation processor generates an example config file (conforming to the specification of Java .properties files) for each annotated interface. That example contains an entry for each accessor method.\nIf an accessor method is optional, the entry in the example will be commented out.\nIf an accessor method provides a default value for a property, the entry in the example will be commented out and the default value is assigned.\nOtherwise (mandatory property, no default value) the entry in the example will not be commented out and does not have an assigned value.\nAny javadoc comments on the accessor methods will be copied as a comment above the corresponding entry in the example file.\nThe generated example file will have the same name as the annotated interface with .properties appended and will be placed in a directory examples. It will be generated in the same path as the generated classes. The example files can then be accessed via their resource path. For an annotated interface ExampleConfig (regardless of the package it is defined in) the corresponding example file can then be accessed in the classpath as /examples/ExampleConfig.properties.\nThis is most useful when packaging an application to include a commented default config file that already contains all valid properties, for example with the maven-assembly-plugin.\nGeneration at runtime The generated config class provides a method writeExampleConfig(java.io.Writer) that allows generating the very same example config at runtime. This is helpful in cases when the example config should only be generated on a users demand.\nCaveats The block tags of the javdoc comments on the accessor methods are stripped off before copying them into the example config.\nHowever at the moment the the remaining javadoc is copied as is. That means all HTML markup and all javadoc tags will be copied, too.\n","link":"https://poiu-de.github.io/coat/docs/user_guide/05_example_config/","title":"Example config"},{"body":"The javadoc for the public classes is published online.\nSee coat-processor for a description of the annotations and coat-runtime for a description of base class for the generated config files and the default converters.\n","link":"https://poiu-de.github.io/coat/docs/user_guide/06_api_reference/","title":"API reference"},{"body":"First public release.\n","link":"https://poiu-de.github.io/coat/docs/release_notes/0.0.1/","title":"0.0.1"},{"body":" CoatConfig#validate() now checks whether config values can be converted to their corresponding type.\nThe generated config classes now provide a method writeExampleConfig to write an example config (in a syntax valid for Java .properties files) to a provided Writer.\nThe annotation processor now generates an example .properties file for each annotated interface.\nThe annotation processor now adds an equals() and hashCode() method to each generated class.\nA new annotation @Coat.Embedded is provided to allow embedding @Code.Config annotated interfaces in other @Coat.Config annotated interfaces. This allows for better reusablity of config classes and improved readability.\n","link":"https://poiu-de.github.io/coat/docs/release_notes/0.0.2/","title":"0.0.2"},{"body":" Use java.lang.System.Logger instead of java.util.logging.Logger in CoatConfig.\nCorrectly handle inherited accessor methods from multiple interfaces.\nAccessor methods that are totally equal will only be generated once. Accessor methods that have the same name, but are otherwise not totally equal (e.g. differing return type or differing default value) prevent the generation.\nCheck that the same key is not used for different accessor methods.\nDon’t try to generate a config from an interface which has methods that return void or accept parameters (as they can’t be used as accessors).\nAdd support for Boolean objects (as opposed to privimitive booleans).\nCorrectly handle numeric values in hexadecimal, binary and octal notation.\n","link":"https://poiu-de.github.io/coat/docs/release_notes/0.0.3/","title":"0.0.3"},{"body":" The @Coat.Param annotation is now optional. All methods in an interface with the @Coat.Config annotation are considered now. The “key” will be inferred from the accessor method name if missing.\nTo influence the style of the inferred keys a CasingStrategy can be specified.\nArrays and Collection types are now supported.\nConverters are provided for “boxed” primitives now.\nConverters can be specified declaratively on the annotation level now (on @Coat.Config and @Coat.Param level). The same is true for ListParsers for the new collection types.\nAllow underscores in numbers for better readablity.\nIgnore non-Coat annotations instead of producing broken code.\nAllow stripping a “get” prefix from the accessor name when inferring the “key”.\n","link":"https://poiu-de.github.io/coat/docs/release_notes/0.0.4/","title":"0.0.4"},{"body":"Generate typesafe config classes Coat is an annotation processor to generate classes for reading configuration values into typesafe objects.\nShort Usage For the following config.properties file appName = My shiny app listenPort = 5040 description = Only a test project Define a corresponding interface 1import de.poiu.coat.annotation.Coat; 2 3@Coat.Config 4public interface MyConfig { 5 public String appName(); 6 7 public int listenPort(); 8 9 public Optional\u0026lt;String\u0026gt; description(); 10} Then use the generated class 1final MyConfig config= 2 new ImmutableMyConfig( 3 new File(\u0026#34;/path/to/config.properties\u0026#34;)); 4 5final String appName = config.appName(); 6final int listenPort = config.listenPort(); 7config.description().ifPresent( 8 … 9); License Coat is licensed under the terms of the Apache license 2.0.\nQuick Start User Guide Example project\n","link":"https://poiu-de.github.io/coat/","title":"Coat — Config of Annotated Types"},{"body":"","link":"https://poiu-de.github.io/coat/docs/release_notes/","title":"Release Notes"},{"body":" There are no immediate plans for the implementation of further features.\nOf course, contributions are welcome to support more features in the future. In any case, before starting to implement a feature, discuss it on the Github issue page to avoid wasted effort due to duplicate work or differing ideas of how a feature should be implemented.\n","link":"https://poiu-de.github.io/coat/docs/roadmap/","title":"Roadmap"}]