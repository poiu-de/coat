[{"body":"Coat provides three annotations, a type-level annotation @Coat.Config and two method-level annotations @Coat.Param and @Coat.Embedded. The annotations are mandatory, but @Coat.Param and @Coat.Embedded are mutual exclusive..\n@Coat.Config Each interface that should be processed by the annotation processor must be annotated with @Coat.Config.\nThe generated class will always be generated in the same package as the annotated interface.\nThe name of the generated class is by the default the interface name with Immutable prepended to it. One exception is if the interface name starts with an underscore. In that case the generated class name is the same as the interface, but with the leading underscore remove. There for the interface _MyConfig the generated class would be MyConfig.\n@Coat.Config supports a single parameter className that can be specified to generate a class with a different name than when applying the above mentioned naming rules. When className is specified it will be used as the generated class name. It will still be generated in the same package as the annotated interface.\n1@Coat.Config(className = \u0026#34;MyAppConfig\u0026#34;) 2public interface AppConfig { 3 … 4} @Coat.Param Each accessor method in the annotated interface must be annotated with @Coat.Param.\nThe mandatory parameter key specifies the name of the key as it must be specified in the config file (or the Properties or Map object with which the config class is instantiated).\nAn optional parameter defaultValue can be specified to define a default value that will be used if the config key is missing in the config file. The default value must be specified as a String in the same form it would be specified in the config file. For example:\n1@Coat.Param(key = \u0026#34;port\u0026#34;, defaultValue = \u0026#34;8080\u0026#34;) 2public int port(); The generated config would return the value that was specified in the config file or 8080 if no port was specified.\n@Coat.Embedded When using [nested configurations](./02_nesting configurations) the annotation @Coat.Embedded must be used instead of @Coat.Param on the corresponding accessor method.\nWhen using @Coat.Embedded the return type of the accessor method must be a @Coat.Config annotated interface.\nThe mandatory parameter key specified the prefix for the config parameters of the embedded config.\nAn optional parameter keySeparator can be specified to define the separator between the prefix and the actual config key of the embedded config. It defaults to a single dot.\n1@Coat.Embedded(key = \u0026#34;mqtt\u0026#34;, keySeparator = \u0026#34;-\u0026#34;) 2public MqttConfig mqtt(); ","link":"https://poiu-de.github.io/coat/docs/user_guide/01_annotations/","title":"Annotations"},{"body":"The Quick Start guide should help getting started with Coat as easy as possible.\nThe User Guide is the thorough description of all aspects of Coat.\nThe Roadmap gives an overview of the possible further enhancement of Coat.\nQuick Start User Guide Roadmap ","link":"https://poiu-de.github.io/coat/docs/","title":"Coat — Config of Annotated Types"},{"body":"Coat has no runtime dependencies on other libraries.\nThe annotation processor has some dependencies on other libraries (which is why it is recommended to use maven as it resolves those dependencies automatically), but none of them are needed at runtime.\nCoat can be used with Java 11 or higher.\n","link":"https://poiu-de.github.io/coat/docs/quick_start/01_prerequisites/","title":"Prerequisites"},{"body":"Starting with Coat is easy. Just write an interface with accessor methods for each field that should be configurable. The return values of the accessor methods can be of any type. Many types are already supported out of the box, but it is possible to use custom types.\nThe source of the configuration data doesn't matter. While it mainly intended to be used for the usual java .properties files, it can be used for any data that is composed of simple String-based key-value-mappings.\nAnnotate the interface with the corresponding Annotations and let the Coat annotation processor generate a concrete implementaion of the interface.\nThat implementation can then be used to retrieve correctly typed config values without any additional effort.\nPrerequisites ","link":"https://poiu-de.github.io/coat/docs/quick_start/","title":"Quick Start"},{"body":"This guide describes all aspects of Coat, how it can be configured an used.\nAnnotations ","link":"https://poiu-de.github.io/coat/docs/user_guide/","title":"User Guide"},{"body":"Coat consists of two separate jars.\n The annotation processor to generate the config classes. Only needed at compile time. The runtime package containing the common base class for all generated config classes and the default type converters. Needed at runtime.  To use Coat in a maven based project use the following maven coordinates:\n1 \u0026lt;!-- Contains the annotation processor. Not needed at runtime. --\u0026gt; 2 \u0026lt;dependency\u0026gt; 3 \u0026lt;groupId\u0026gt;de.poiu.coat\u0026lt;/groupId\u0026gt; 4 \u0026lt;artifactId\u0026gt;coat-processor\u0026lt;/artifactId\u0026gt; 5 \u0026lt;version\u0026gt;0.0.2\u0026lt;/version\u0026gt; 6 \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; 7 \u0026lt;/dependency\u0026gt; 8 9 \u0026lt;!-- Contains the converters and base classes. Needed at runtime. --\u0026gt; 10 \u0026lt;dependency\u0026gt; 11 \u0026lt;groupId\u0026gt;de.poiu.coat\u0026lt;/groupId\u0026gt; 12 \u0026lt;artifactId\u0026gt;coat-runtime\u0026lt;/artifactId\u0026gt; 13 \u0026lt;version\u0026gt;0.0.2\u0026lt;/version\u0026gt; 14 \u0026lt;/dependency\u0026gt; ","link":"https://poiu-de.github.io/coat/docs/quick_start/02_installation/","title":"Installation"},{"body":"Coat allows embedding config objects in other config objects.\nIt is helpful in the case if parts of a configuration are reused in multiple other configurations without having to duplicate all the accessor methods of the embedded config class.\nExample As an example see the following MqttConfig that is embedded in the main AppConfig.\n1@Coat.Config 2public interface MqttConfig { 3 4 @Coat.Param(key = \u0026#34;client_id\u0026#34;) 5 public Optional\u0026lt;String\u0026gt; clientId(); 6 7 @Coat.Param(key = \u0026#34;broker_address\u0026#34;) 8 public InetAddress brokerAddress(); 9 10 @Coat.Param(key = \u0026#34;port\u0026#34;, defaultValue = \u0026#34;1883\u0026#34;) 11 public int port(); 1@Coat.Config 2public interface AppConfig { 3 4 @Coat.Param(key = \u0026#34;name\u0026#34;) 5 public String name(); 6 7 @Coat.Embedded(key = \u0026#34;mqtt\u0026#34;) 8 public MqttConfig mqtt(); A config file for that configuration would look like this:\nname = … mqtt.client_id = … mqtt.broker_address = … mqtt.port = … The config keys of the embedded config get a common prefix that is specified on the @Coat.Embedded annotation of its accessor method. By default that prefix is separated from the actual config key via a single dot.\n","link":"https://poiu-de.github.io/coat/docs/user_guide/02_nesting_configurations/","title":"Nesting Configurations"},{"body":"Create config interface Write an interface with accessor methods for each config entry your application supports. The accessor methods can return to concrete types you want your config entry to be. There is number of types that are supported by default, but custom types can be registered to support additional types.\nConfig values that are optional, must be of type java.util.Optional or the more specialized variants OptionalInt, OptionalLong or OptionalDouble. All other config values are considered mandatory. Missing mandatory values will throw exceptions at runtime.\nThe interface must be annotated with the @Coat.Config annotation for the annotation processor to recognize it.\nAlso, each accessor must be annotated with the @Coat.Param annotation to tell the processor the corresponding key in the config file.\nFor example:\n1package com.example; 2 3import de.poiu.coat.annotation.Coat; 4 5@Coat.Config 6public interface AppConfig { 7 @Coat.Param(key = \u0026#34;appName\u0026#34;) 8 public String appName(); 9 10 @Coat.Param(key = \u0026#34;remoteIP\u0026#34;) 11 public InetAddress remoteIP(); 12 13 @Coat.Param(key = \u0026#34;remotePort\u0026#34;) 14 public int remotePort(); 15 16 @Coat.Param(key = \u0026#34;desription\u0026#34;) 17 public Optional\u0026lt;String\u0026gt; description(); 18} Generate concrete config class When compiling the project the annotation processor will produce a concreate implementation of the interface in the same package and (by default) the same name with Immutable prepended to it. Therefore the above example interface would produce a com.example.ImmutableAppConfig class.\nUse the generated config class At runtime the generated config class can be instantiated with either a java.io.File object referencing the actual config file, a java.util.Properties object or, if the config data is read from some other source, with a java.util.Map\u0026lt;String, String\u0026gt;.\nThe instantiated config object can be validated to fail early in case mandatory config values are missing or existing values cannot be converted to the expected type.\n1public class MyApp { 2 public static void main(String[] args) { 3 final ImmutableAppConfig config= new ImmutableAppConfig( 4 new File(\u0026#34;/path/to/config.properties\u0026#34;)); 5 6 try { 7 config.validate(); 8 } catch (final ConfigValidationException ex) { 9 System.err.println(\u0026#34;Error in config file:\\n\u0026#34; 10 + ex.getValidationResult().toString()); 11 System.exit(1); 12 } 13 14 System.out.println(\u0026#34;Starting \u0026#34; + config.appName()); 15 config.description.ifPresent(System.out::println); 16 17 final Socket s= new Socket(config.remoteIP, config.remotePort); 18 19 … 20 } 21} ","link":"https://poiu-de.github.io/coat/docs/quick_start/03_usage/","title":"Usage"},{"body":"The generated config class allows the validation of the configuration with the method validate(). This can be used to fail early in case the given configuration is missing some values or existing values cannot be converted into the specified type.\nIf the configuration is valid this method just returns.\nIf the configuration is invalid, it will throw a ConfigValidationException. This exception has a method getValidationResult() that returns a value of type ValidationResult that contains more information about the missing or wrong config values.\nTo issue an error message, the toString() method of the ValidationResult can be used. For example\n1try { 2 config.validate(); 3} catch (final ConfigValidationException ex) { 4 System.err.println(\u0026#34;Error in config file:\\n\u0026#34; 5 + ex.getValidationResult().toString()); 6 System.exit(1); 7} ","link":"https://poiu-de.github.io/coat/docs/user_guide/03_validation/","title":"Validation"},{"body":"Builtin types The following types are supported by Coat out of the box and can directly be used as return types of the accessor methods in the annotated interface.\n java.lang.String java.time.Duration java.time.LocalDate java.time.LocalDateTime java.time.LocalTime java.io.File java.nio.file.Path java.nio.charset.Charset java.net.InetAddress java.security.MessageDigest  For each supported type a converter class exists in the package de.poiu.coat.convert. Refer to the corresponding Java API docs for details about the expected format of the input string.\nThe following primitive types are also supported by default. But those are different in that they are directly supported without any Converter.\n int long double boolean  Registering custom types Coat allows registering custom types to be used in the annotated interface.\nEach generated config class provides a static method registerConverter() that can be used to register a converter for a specific type. To do this, the interface de.poiu.coat.convert.Converter must be implemented for that specific type and registered with the above mentioned method.\nThe registerConverter() method must be called before an accessor method returning that type is called and before the validate() method is called.\nThe registerConverter() method can additionally be used for overriding the builtin converter for a type. For example if duration should be specified in some other format than the default converter supports, write a custom converter for the java.time.Duration type and register it via\n1ImmutableMyConfig.registerConverter(Duration.class, new MyDurationConverter()); As support for primitive types is directly implemented and not via Converter it is currently not possible to override the parsing of primitve types with a custom converter. If different parsing of such types is necessary the corresponding object type must be used and a Converter for that type written (e. g. a Converter(Integer)).\nCurrently unsupported types At the moment no arrays or collection types are supported by Coat. Trying to specify an array or a collection of a generic type will lead to undefined behaviour.\nSupport for arrays and collection types is in the roadmap, but not implemented yet.\nAlso at the moment the primitive types short, float, char and byte are not supported. Therefore the next \u0026quot;bigger\u0026quot; types must be used (e. g. int instead of short) or the corresponding class (e. g. Short instead of short).\n","link":"https://poiu-de.github.io/coat/docs/user_guide/04_supported_types/","title":"Supported Types"},{"body":"Example config file generation The annotation processor generates an example config file (according to the specification of Java .properties files) for each annotated interface. That example contains an entry for each accessor method.\nIf an accessor method is optional, the entry in the example will be commented out.\nIf an accessor method provides a default value for a property, the entry in the example will be commented out and the default value is assigned.\nOtherwise (mandatory property, no default value) the entry in the example will not be commented out and does not have an assigned value.\nAny javadoc comments on the accessor methods will be copied as a comment above the corresponding entry in the example file.\nThe generated example file will have the same name as the annotated interface with .properties appended and will be placed in a directory examples. It will be generated in the same path as the generated classes. The example files can then be accessed via their resource path. For an annotated interface ExampleConfig (regardless of the package it is defined in) the corresponding example file can then be accessed in the classpath as /examples/ExampleConfig.properties.\nThis is most useful when packaging an application to include a commented default config file that already contains all valid properties, for example with the maven-assembly-plugin.\nGeneration at runtime The generated config class provides a method writeExampleConfig(java.io.Writer that allows generating the very same example config at runtime. This is helpful in cases the example config should only be generated on a users demand.\nCaveats The block tags of the javdoc comments on the accessor methods are stripped off before copying them into the example config.\nHowever at the moment the the remaining javadoc is copied as is. That means all HTML markup and all javadoc tags will be copied, too.\n","link":"https://poiu-de.github.io/coat/docs/user_guide/05_example_config/","title":"Example config"},{"body":"First public release.\n","link":"https://poiu-de.github.io/coat/docs/release_notes/0.0.1/","title":"0.0.1"},{"body":"  CoatConfig#validate() now checks whether config values can be converted to their corresponding type.\n  The generated config classes now provide a method writeExampleConfig to write an example config (in a syntax valid for Java .properties files) to a provided Writer.\n  The annotation processor now generates an example .properties file for each annotated interface.\n  The annotation processor now adds an equals() and hashCode() method to each generated class.\n  A new annotation @Coat.Embedded is provided to allow embedding @Code.Config annotated interfaces in other @Coat.Config annotated interfaces. This allows for better reusablity of config classes and improved readability.\n  ","link":"https://poiu-de.github.io/coat/docs/release_notes/0.0.2/","title":"0.0.2"},{"body":"Generate typesafe config classes Coat is an annotation processor to generate classes for reading configuration values into typesafe objects.\nShort Usage  For the following config.properties file  appName = My shiny app listenPort = 5040 description = Only a test project  Define a corresponding interface  1import de.poiu.coat.annotation.Coat; 2 3@Coat.Config 4public interface MyConfig { 5 @Coat.Param(key = \u0026#34;appName\u0026#34;) 6 public String appName(); 7 8 @Coat.Param(key = \u0026#34;listenPort\u0026#34;, defaultValue = \u0026#39;8080\u0026#39;) 9 public int listenPort(); 10 11 @Coat.Param(key = \u0026#34;desription\u0026#34;) 12 public Optional\u0026lt;String\u0026gt; description(); 13}  Then use the generated class  1final MyConfig config= 2 new ImmutableMyConfig( 3 new File(\u0026#34;/path/to/config.properties\u0026#34;)); 4 5final String appName = config.appName(); 6final int listenPort = config.listenPort(); 7config.description().ifPresent( 8 … 9); 10 11 12 13   License Coat is licensed under the terms of the Apache license 2.0.\nQuick Start User Guide\n","link":"https://poiu-de.github.io/coat/","title":"Coat — Config of Annotated Types"},{"body":"Support for arrays and collection types At the moment it is not possible to use arrays or collections with generic types in config classes. This is quiet some drawback and it is planned to be supported in the future.\nGeneration of example config files As the annotated interface is the specification of the whole valid configuration it would be possible and in fact desirable to let Coat generate an example config file conforming to that specification.\nOptional values could be included, but commented out.\nThe javadoc for each accessor method could be copied as the description of the corresponding entry in the example config file.\nNested configuration options At the moment only flat config files are supported.\nIt would be nice to nest config values to encapsulate and reuse them.\nFor example the following config interface\n1@Coat.Config 2public interface MyConfig { 3 @Coat.Param (key = \u0026#34;appName\u0026#34;) 4 public String appName(); 5 6 @Coat.Param (key = \u0026#34;mqtt.server\u0026#34;) 7 public String mqttServer(); 8 9 @Coat.Param (key = \u0026#34;mqtt.port\u0026#34;, defaultValue = \u0026#34;1883\u0026#34;) 10 public String mqttPort(); 11 12 @Coat.Param (key = \u0026#34;mqtt.clientId\u0026#34;) 13 public Optional\u0026lt;String\u0026gt; mqttClientId(); 14} could then be defined as\n1@Coat.Config 2public interface MyConfig { 3 @Coat.Param (key = \u0026#34;appName\u0026#34;) 4 public String appName(); 5 6 @Coat.Param (key = \u0026#34;mqtt\u0026#34;) 7 public MqttConfig mqttConfig(); 8} 9 10public interface MqttConfig { 11 @Coat.Param (key = \u0026#34;server\u0026#34;) 12 public String server(); 13 14 @Coat.Param (key = \u0026#34;port\u0026#34;, defaultValue = \u0026#34;1883\u0026#34;) 15 public String port(); 16 17 @Coat.Param (key = \u0026#34;clientId\u0026#34;) 18 public Optional\u0026lt;String\u0026gt; clientId(); 19} Declarative declaration of custom converters Custom converters can only be specified programmatically and globally at runtime.\nit would be nice to support a declarative declaration of custom converters in the @Coat.Config and/or @Coat.Param annotation.\nThis is a low priority goal as the actual real-world benefit is unclear.\n","link":"https://poiu-de.github.io/coat/docs/roadmap/01_planned_features/","title":"Planned Features"},{"body":"","link":"https://poiu-de.github.io/coat/docs/release_notes/","title":"Release Notes"},{"body":"Coat is a project in its early stages. There are some features that are planned, but not yet implemented.\nThis roadmap lists some features that should be supported in future versions of Coat.\nBe aware that this is just a \u0026quot;vision\u0026quot; of Coats future. That some feature is listed in this roadmap does not necessarily mean that it will definitly be implemented. It may even be that some feature is planned in this roadmap even it is technically not possible to implement.\nOf course, contributions are welcome to support more features in the future. In any case, before starting to implement a feature, discuss it on the Github issue page to avoid wasted effort due to duplicate work or differing ideas of how a feature should be implemented.\n","link":"https://poiu-de.github.io/coat/docs/roadmap/","title":"Roadmap"}]